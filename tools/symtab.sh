#!/bin/sh
#
# tools/symtab.sh
#
# Copyright (C) 2007 Alexander Shishkin
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# This script generates a list of all in-kernel function symbols
# so that we can better decipher the stack traces.

usage() {
	echo "Usage: $0 <input file> <output file>"
	echo "  <input file>  must be elf with nitty functions inside"
	echo "  <output file> is where to write the resulting C code."
	exit 1
}

ELFFILE="$1"
if test -z "$ELFFILE"; then
	usage
fi

OUTFILE="$2"
if test -z "$OUTFILE"; then
	usage
fi

objdump -t "$ELFFILE" | sort -k1 | gawk -v myname="$0" '
	BEGIN {
		printf "/*\n * This file is automatically generated by %s,\n", myname;
		printf " * do not edit.\n */\n\n";
		printf "#define __GENERIC_SYMTAB__\n";
		printf "#ifndef LO_CORE\n";
		printf "#include <symtab.h>\n\n";
		printf "struct symbol symbol_table[] = {\n";
		start_addr = 0;
		end_addr = 0;
		symcount = 0;
		kos_entry = 0;
	}
	END {
		printf "\n};\n\n";
		printf "unsigned long start_addr = 0x%08x;\n", start_addr;
		printf "unsigned long end_addr   = 0x%08x;\n", end_addr;
		printf "unsigned long total_symbols = %d;\n\n", symcount;
		printf "#endif /* LO_CORE */\n\n";
		printf "#define KOS_ENTRY 0x%08x\n\n", kos_entry
	}
	/ F / {
		if ($1 != 0 && $5 != 0) {
			addr = strtonum(sprintf("0x%s", $1));
			size = strtonum(sprintf("0x%s", $5));
			section = $4;
			name = $6;

			start_addr = start_addr ? start_addr : addr;
			end_addr = (addr + size);
			symcount++;

			printf "\t{\n\t\t.addr = 0x%08x,\n", addr;
			printf "\t\t.size = 0x%08x,\n", size;
			printf "\t\t.section = \"%s\",\n", section;
			printf "\t\t.name = \"%s\"\n\t},\n", name;

			if (name == "multiboot_start")
				kos_entry = addr;
		}
	}
' > "$OUTFILE"

